{
  "permissions": {
    "allow": [
      "Bash(node:*)",
      "Bash(npm --version:*)",
      "Bash(git --version)",
      "Bash(npm create:*)",
      "Bash(npx:*)",
      "Bash(npm init:*)",
      "Bash(npm install:*)",
      "Bash(\"H:\\\\programmazione\\\\Claude\\\\test\\\\public\\\\favicon.svg\" << 'SVGEOF'\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n  <rect width=\"512\" height=\"512\" rx=\"64\" fill=\"#2563eb\"/>\n  <text x=\"256\" y=\"340\" font-family=\"Arial, Helvetica, sans-serif\" font-size=\"300\" font-weight=\"bold\" fill=\"white\" text-anchor=\"middle\">S</text>\n</svg>\nSVGEOF)",
      "Bash(\"H:\\\\programmazione\\\\Claude\\\\test\\\\generate-icons.mjs\" << 'NODEOF'\n/**\n * Generate PWA icon PNGs for SpeseDivise\n * No external dependencies - uses raw PNG binary encoding.\n *\n * Each icon is a blue rounded-rect-ish square with a white \"S\" drawn\n * using simple filled rectangles \\(a bitmap font approach\\).\n */\n\nimport { writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { deflateSync } from 'node:zlib';\n\nconst DIR = join\\(import.meta.dirname, 'public'\\);\n\n// ── tiny helpers ──────────────────────────────────────────────────\nfunction crc32\\(buf\\) {\n  let table = new Int32Array\\(256\\);\n  for \\(let n = 0; n < 256; n++\\) {\n    let c = n;\n    for \\(let k = 0; k < 8; k++\\) c = \\(c & 1\\) ? \\(0xEDB88320 ^ \\(c >>> 1\\)\\) : \\(c >>> 1\\);\n    table[n] = c;\n  }\n  let crc = -1;\n  for \\(let i = 0; i < buf.length; i++\\) crc = \\(crc >>> 8\\) ^ table[\\(crc ^ buf[i]\\) & 0xff];\n  return \\(crc ^ -1\\) >>> 0;\n}\n\nfunction chunk\\(type, data\\) {\n  const len = Buffer.alloc\\(4\\);\n  len.writeUInt32BE\\(data.length\\);\n  const typeAndData = Buffer.concat\\([Buffer.from\\(type, 'ascii'\\), data]\\);\n  const crc = Buffer.alloc\\(4\\);\n  crc.writeUInt32BE\\(crc32\\(typeAndData\\)\\);\n  return Buffer.concat\\([len, typeAndData, crc]\\);\n}\n\n// ── rasteriser ────────────────────────────────────────────────────\nfunction makeImage\\(size, maskable\\) {\n  const pixels = Buffer.alloc\\(size * size * 4\\); // RGBA\n\n  const BG   = [37, 99, 235, 255];   // #2563EB\n  const WHITE = [255, 255, 255, 255];\n  const SAFE  = maskable ? Math.floor\\(size * 0.1\\) : 0;  // 10 % safe-area inset\n\n  // fill background\n  for \\(let i = 0; i < size * size; i++\\) {\n    pixels[i * 4]     = BG[0];\n    pixels[i * 4 + 1] = BG[1];\n    pixels[i * 4 + 2] = BG[2];\n    pixels[i * 4 + 3] = BG[3];\n  }\n\n  // optional rounded corners \\(approximate: clip corners to transparent\\)\n  const radius = Math.floor\\(size * 0.12\\);\n  for \\(let y = 0; y < size; y++\\) {\n    for \\(let x = 0; x < size; x++\\) {\n      let cx, cy;\n      if \\(x < radius && y < radius\\)                        { cx = radius; cy = radius; }\n      else if \\(x >= size - radius && y < radius\\)            { cx = size - radius - 1; cy = radius; }\n      else if \\(x < radius && y >= size - radius\\)            { cx = radius; cy = size - radius - 1; }\n      else if \\(x >= size - radius && y >= size - radius\\)    { cx = size - radius - 1; cy = size - radius - 1; }\n      else continue;\n      const dx = x - cx, dy = y - cy;\n      if \\(dx * dx + dy * dy > radius * radius\\) {\n        const idx = \\(y * size + x\\) * 4;\n        pixels[idx + 3] = 0; // transparent\n      }\n    }\n  }\n\n  // Draw the letter \"S\" as a set of filled rectangles \\(bitmap-style\\)\n  // We define S on a 5×7 grid, then scale it to fit the icon.\n  // S pattern \\(row, col\\) where 1 = filled:\n  //  .XXX.\n  //  X....\n  //  X....\n  //  .XXX.\n  //  ....X\n  //  ....X\n  //  XXX..\n  const sGrid = [\n    [0,1,1,1,0],\n    [1,0,0,0,0],\n    [1,0,0,0,0],\n    [0,1,1,1,0],\n    [0,0,0,0,1],\n    [0,0,0,0,1],\n    [1,1,1,0,0],\n  ];\n\n  const gridW = 5, gridH = 7;\n  const letterArea = size - 2 * SAFE;\n  const cellW = Math.floor\\(letterArea * 0.12\\);\n  const cellH = Math.floor\\(letterArea * 0.09\\);\n  const totalW = gridW * cellW;\n  const totalH = gridH * cellH;\n  const offX = SAFE + Math.floor\\(\\(letterArea - totalW\\) / 2\\);\n  const offY = SAFE + Math.floor\\(\\(letterArea - totalH\\) / 2\\);\n\n  function fillRect\\(rx, ry, rw, rh, color\\) {\n    for \\(let dy = 0; dy < rh; dy++\\) {\n      for \\(let dx = 0; dx < rw; dx++\\) {\n        const px = rx + dx, py = ry + dy;\n        if \\(px >= 0 && px < size && py >= 0 && py < size\\) {\n          const idx = \\(py * size + px\\) * 4;\n          pixels[idx]     = color[0];\n          pixels[idx + 1] = color[1];\n          pixels[idx + 2] = color[2];\n          pixels[idx + 3] = color[3];\n        }\n      }\n    }\n  }\n\n  for \\(let r = 0; r < gridH; r++\\) {\n    for \\(let c = 0; c < gridW; c++\\) {\n      if \\(sGrid[r][c]\\) {\n        fillRect\\(offX + c * cellW, offY + r * cellH, cellW, cellH, WHITE\\);\n      }\n    }\n  }\n\n  // ── encode PNG ──────────────────────────────────────────────────\n  // Build raw scanlines: each row = filter byte \\(0\\) + RGBA data\n  const raw = Buffer.alloc\\(size * \\(1 + size * 4\\)\\);\n  for \\(let y = 0; y < size; y++\\) {\n    const rowOff = y * \\(1 + size * 4\\);\n    raw[rowOff] = 0; // no filter\n    pixels.copy\\(raw, rowOff + 1, y * size * 4, \\(y + 1\\) * size * 4\\);\n  }\n\n  const compressed = deflateSync\\(raw\\);\n\n  const sig = Buffer.from\\([137, 80, 78, 71, 13, 10, 26, 10]\\);\n\n  // IHDR\n  const ihdrData = Buffer.alloc\\(13\\);\n  ihdrData.writeUInt32BE\\(size, 0\\);\n  ihdrData.writeUInt32BE\\(size, 4\\);\n  ihdrData[8]  = 8; // bit depth\n  ihdrData[9]  = 6; // color type: RGBA\n  ihdrData[10] = 0; // compression\n  ihdrData[11] = 0; // filter\n  ihdrData[12] = 0; // interlace\n\n  const png = Buffer.concat\\([\n    sig,\n    chunk\\('IHDR', ihdrData\\),\n    chunk\\('IDAT', compressed\\),\n    chunk\\('IEND', Buffer.alloc\\(0\\)\\),\n  ]\\);\n\n  return png;\n}\n\n// ── ICO helper \\(wraps a PNG inside an ICO container\\) ─────────────\nfunction makeIco\\(pngBuf, displaySize\\) {\n  // ICO header \\(6 bytes\\) + 1 entry \\(16 bytes\\) + PNG data\n  const header = Buffer.alloc\\(6\\);\n  header.writeUInt16LE\\(0, 0\\);  // reserved\n  header.writeUInt16LE\\(1, 2\\);  // type: icon\n  header.writeUInt16LE\\(1, 4\\);  // count\n\n  const entry = Buffer.alloc\\(16\\);\n  entry[0] = displaySize < 256 ? displaySize : 0; // width  \\(0 = 256\\)\n  entry[1] = displaySize < 256 ? displaySize : 0; // height\n  entry[2] = 0;  // palette\n  entry[3] = 0;  // reserved\n  entry.writeUInt16LE\\(1, 4\\);  // planes\n  entry.writeUInt16LE\\(32, 6\\); // bits per pixel\n  entry.writeUInt32LE\\(pngBuf.length, 8\\);  // data size\n  entry.writeUInt32LE\\(22, 12\\);            // data offset \\(6+16\\)\n\n  return Buffer.concat\\([header, entry, pngBuf]\\);\n}\n\n// ── generate all icons ───────────────────────────────────────────\nconst icons = [\n  { name: 'pwa-192x192.png',          size: 192, maskable: false },\n  { name: 'pwa-512x512.png',          size: 512, maskable: false },\n  { name: 'pwa-maskable-512x512.png', size: 512, maskable: true  },\n  { name: 'apple-touch-icon.png',     size: 180, maskable: false },\n];\n\nfor \\(const { name, size, maskable } of icons\\) {\n  const png = makeImage\\(size, maskable\\);\n  const outPath = join\\(DIR, name\\);\n  writeFileSync\\(outPath, png\\);\n  console.log\\(`wrote ${outPath}  \\(${png.length} bytes, ${size}x${size}\\)`\\);\n}\n\n// favicon.ico  – 32x32 PNG wrapped in ICO\nconst fav32 = makeImage\\(32, false\\);\nconst ico = makeIco\\(fav32, 32\\);\nconst icoPath = join\\(DIR, 'favicon.ico'\\);\nwriteFileSync\\(icoPath, ico\\);\nconsole.log\\(`wrote ${icoPath}  \\(${ico.length} bytes, 32x32 ICO\\)`\\);\n\nconsole.log\\('\\\\nAll icons generated successfully.'\\);\nNODEOF)",
      "Bash(del \"H:\\\\programmazione\\\\Claude\\\\test\\\\generate-icons.mjs\")"
    ]
  }
}
